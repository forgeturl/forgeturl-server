// Code generated by protoc-gen-go-gin. DO NOT EDIT.
// versions:
// - protoc-gen-go-gin v1.0.0
// - protoc            v4.24.2
// source: api/proto/ecode.proto

package common

import (
	errors "errors"
	ecode "github.com/sunmi-OS/gocore/v2/api/ecode"
)

const (
	ERR_COMMON_UNKNOWN                = 0
	ERR_BAD_REQUEST                   = 400
	ERR_NOT_AUTHENTICATED             = 401
	ERR_FORBIDDEN                     = 403
	ERR_NOT_FOUND                     = 404
	ERR_METHOD_NOT_ALLOWED            = 405
	ERR_REQUEST_TIMEOUT               = 408
	ERR_CONFLICT                      = 409
	ERR_GONE                          = 410
	ERR_REQUEST_ENTITY_TOO_LARGE      = 413
	ERR_RANGE_NOT_SATISFIABLE         = 416
	ERR_TOO_MANY_REQUESTS             = 429
	ERR_INTERNAL_SERVER_ERROR         = 500
	ERR_NOT_IMPLEMENTED               = 501
	ERR_BAD_GATEWAY                   = 502
	ERR_SERVICE_UNAVAILABLE           = 503
	ERR_GATEWAY_TIMEOUT               = 504
	ERR_NEED_LOGIN                    = 40001
	ERR_NOT_SUPPORT                   = 40002
	ERR_UPDATE_MISS_NEED_REFRESH_PAGE = 40003
)

var (
	ErrMap = map[int]string{
		ERR_COMMON_UNKNOWN:                "common unknown",
		ERR_BAD_REQUEST:                   "Bad request",
		ERR_NOT_AUTHENTICATED:             "Not authorized",
		ERR_FORBIDDEN:                     "Forbidden",
		ERR_NOT_FOUND:                     "Not found",
		ERR_METHOD_NOT_ALLOWED:            "Method not allowed",
		ERR_REQUEST_TIMEOUT:               "Request timeout",
		ERR_CONFLICT:                      "Conflict",
		ERR_GONE:                          "Resource gone",
		ERR_REQUEST_ENTITY_TOO_LARGE:      "Request entity too large",
		ERR_RANGE_NOT_SATISFIABLE:         "Range not satisfiable",
		ERR_TOO_MANY_REQUESTS:             "Too many requests",
		ERR_INTERNAL_SERVER_ERROR:         "Internal server error",
		ERR_NOT_IMPLEMENTED:               "Server not implemented this function",
		ERR_BAD_GATEWAY:                   "Bad gateway",
		ERR_SERVICE_UNAVAILABLE:           "Service unavailable",
		ERR_GATEWAY_TIMEOUT:               "Gateway timeout",
		ERR_NEED_LOGIN:                    "need login",
		ERR_NOT_SUPPORT:                   "The operation is not supported",
		ERR_UPDATE_MISS_NEED_REFRESH_PAGE: "This page has been modified, please refresh and try again!",
	}
)

func makeNewErr(code int, msg ...string) *ecode.ErrorV2 {
	msgStr := ErrMap[code]
	if len(msg) > 0 {
		msgStr = msg[0]
	}
	return ecode.NewV2(code, msgStr)
}

// code: 0 msg: "common unknown"
func ErrCommonUnknown(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_COMMON_UNKNOWN, msg...)
}

// code: 400 msg: "Bad request"
func ErrBadRequest(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_BAD_REQUEST, msg...)
}

// code: 401 msg: "Not authorized"
func ErrNotAuthenticated(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_NOT_AUTHENTICATED, msg...)
}

// code: 403 msg: "Forbidden"
func ErrForbidden(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_FORBIDDEN, msg...)
}

// code: 404 msg: "Not found"
func ErrNotFound(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_NOT_FOUND, msg...)
}

// code: 405 msg: "Method not allowed"
func ErrMethodNotAllowed(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_METHOD_NOT_ALLOWED, msg...)
}

// code: 408 msg: "Request timeout"
func ErrRequestTimeout(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_REQUEST_TIMEOUT, msg...)
}

// code: 409 msg: "Conflict"
func ErrConflict(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_CONFLICT, msg...)
}

// code: 410 msg: "Resource gone"
func ErrGone(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_GONE, msg...)
}

// code: 413 msg: "Request entity too large"
func ErrRequestEntityTooLarge(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_REQUEST_ENTITY_TOO_LARGE, msg...)
}

// code: 416 msg: "Range not satisfiable"
func ErrRangeNotSatisfiable(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_RANGE_NOT_SATISFIABLE, msg...)
}

// code: 429 msg: "Too many requests"
func ErrTooManyRequests(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_TOO_MANY_REQUESTS, msg...)
}

// code: 500 msg: "Internal server error"
func ErrInternalServerError(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_INTERNAL_SERVER_ERROR, msg...)
}

// code: 501 msg: "Server not implemented this function"
func ErrNotImplemented(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_NOT_IMPLEMENTED, msg...)
}

// code: 502 msg: "Bad gateway"
func ErrBadGateway(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_BAD_GATEWAY, msg...)
}

// code: 503 msg: "Service unavailable"
func ErrServiceUnavailable(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_SERVICE_UNAVAILABLE, msg...)
}

// code: 504 msg: "Gateway timeout"
func ErrGatewayTimeout(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_GATEWAY_TIMEOUT, msg...)
}

// code: 40001 msg: "need login"
func ErrNeedLogin(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_NEED_LOGIN, msg...)
}

// code: 40002 msg: "The operation is not supported"
func ErrNotSupport(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_NOT_SUPPORT, msg...)
}

// code: 40003 msg: "This page has been modified, please refresh and try again!"
func ErrUpdateMissNeedRefreshPage(msg ...string) *ecode.ErrorV2 {
	return makeNewErr(ERR_UPDATE_MISS_NEED_REFRESH_PAGE, msg...)
}

func IsErrCommonUnknown(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_COMMON_UNKNOWN
	}
	return false
}

func IsErrCommonUnknownDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_COMMON_UNKNOWN && se.Message() == ErrMap[ERR_COMMON_UNKNOWN]
	}
	return false
}

func IsErrBadRequest(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_BAD_REQUEST
	}
	return false
}

func IsErrBadRequestDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_BAD_REQUEST && se.Message() == ErrMap[ERR_BAD_REQUEST]
	}
	return false
}

func IsErrNotAuthenticated(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_NOT_AUTHENTICATED
	}
	return false
}

func IsErrNotAuthenticatedDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_NOT_AUTHENTICATED && se.Message() == ErrMap[ERR_NOT_AUTHENTICATED]
	}
	return false
}

func IsErrForbidden(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_FORBIDDEN
	}
	return false
}

func IsErrForbiddenDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_FORBIDDEN && se.Message() == ErrMap[ERR_FORBIDDEN]
	}
	return false
}

func IsErrNotFound(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_NOT_FOUND
	}
	return false
}

func IsErrNotFoundDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_NOT_FOUND && se.Message() == ErrMap[ERR_NOT_FOUND]
	}
	return false
}

func IsErrMethodNotAllowed(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_METHOD_NOT_ALLOWED
	}
	return false
}

func IsErrMethodNotAllowedDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_METHOD_NOT_ALLOWED && se.Message() == ErrMap[ERR_METHOD_NOT_ALLOWED]
	}
	return false
}

func IsErrRequestTimeout(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_REQUEST_TIMEOUT
	}
	return false
}

func IsErrRequestTimeoutDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_REQUEST_TIMEOUT && se.Message() == ErrMap[ERR_REQUEST_TIMEOUT]
	}
	return false
}

func IsErrConflict(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_CONFLICT
	}
	return false
}

func IsErrConflictDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_CONFLICT && se.Message() == ErrMap[ERR_CONFLICT]
	}
	return false
}

func IsErrGone(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_GONE
	}
	return false
}

func IsErrGoneDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_GONE && se.Message() == ErrMap[ERR_GONE]
	}
	return false
}

func IsErrRequestEntityTooLarge(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_REQUEST_ENTITY_TOO_LARGE
	}
	return false
}

func IsErrRequestEntityTooLargeDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_REQUEST_ENTITY_TOO_LARGE && se.Message() == ErrMap[ERR_REQUEST_ENTITY_TOO_LARGE]
	}
	return false
}

func IsErrRangeNotSatisfiable(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_RANGE_NOT_SATISFIABLE
	}
	return false
}

func IsErrRangeNotSatisfiableDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_RANGE_NOT_SATISFIABLE && se.Message() == ErrMap[ERR_RANGE_NOT_SATISFIABLE]
	}
	return false
}

func IsErrTooManyRequests(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_TOO_MANY_REQUESTS
	}
	return false
}

func IsErrTooManyRequestsDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_TOO_MANY_REQUESTS && se.Message() == ErrMap[ERR_TOO_MANY_REQUESTS]
	}
	return false
}

func IsErrInternalServerError(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_INTERNAL_SERVER_ERROR
	}
	return false
}

func IsErrInternalServerErrorDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_INTERNAL_SERVER_ERROR && se.Message() == ErrMap[ERR_INTERNAL_SERVER_ERROR]
	}
	return false
}

func IsErrNotImplemented(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_NOT_IMPLEMENTED
	}
	return false
}

func IsErrNotImplementedDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_NOT_IMPLEMENTED && se.Message() == ErrMap[ERR_NOT_IMPLEMENTED]
	}
	return false
}

func IsErrBadGateway(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_BAD_GATEWAY
	}
	return false
}

func IsErrBadGatewayDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_BAD_GATEWAY && se.Message() == ErrMap[ERR_BAD_GATEWAY]
	}
	return false
}

func IsErrServiceUnavailable(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_SERVICE_UNAVAILABLE
	}
	return false
}

func IsErrServiceUnavailableDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_SERVICE_UNAVAILABLE && se.Message() == ErrMap[ERR_SERVICE_UNAVAILABLE]
	}
	return false
}

func IsErrGatewayTimeout(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_GATEWAY_TIMEOUT
	}
	return false
}

func IsErrGatewayTimeoutDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_GATEWAY_TIMEOUT && se.Message() == ErrMap[ERR_GATEWAY_TIMEOUT]
	}
	return false
}

func IsErrNeedLogin(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_NEED_LOGIN
	}
	return false
}

func IsErrNeedLoginDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_NEED_LOGIN && se.Message() == ErrMap[ERR_NEED_LOGIN]
	}
	return false
}

func IsErrNotSupport(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_NOT_SUPPORT
	}
	return false
}

func IsErrNotSupportDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_NOT_SUPPORT && se.Message() == ErrMap[ERR_NOT_SUPPORT]
	}
	return false
}

func IsErrUpdateMissNeedRefreshPage(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_UPDATE_MISS_NEED_REFRESH_PAGE
	}
	return false
}

func IsErrUpdateMissNeedRefreshPageDEEP(err error) bool {
	if se := new(ecode.ErrorV2); errors.As(err, &se) {
		return se.Code() == ERR_UPDATE_MISS_NEED_REFRESH_PAGE && se.Message() == ErrMap[ERR_UPDATE_MISS_NEED_REFRESH_PAGE]
	}
	return false
}
