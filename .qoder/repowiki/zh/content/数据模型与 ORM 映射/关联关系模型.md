# 关联关系模型

<cite>
**本文档中引用的文件**  
- [user_page.sql](file://app/dal/gensql/user_page.sql)
- [unique_pid.sql](file://app/dal/gensql/unique_pid.sql)
- [user_page.gen.go](file://app/dal/model/user_page.gen.go)
- [unique_pid.gen.go](file://app/dal/model/unique_pid.gen.go)
- [user_page.gen.go](file://app/dal/query/user_page.gen.go)
- [unique_pid.gen.go](file://app/dal/query/unique_pid.gen.go)
- [gen.go](file://app/dal/query/gen.go)
</cite>

## 目录
1. [引言](#引言)
2. [用户-页面关联模型](#用户-页面关联模型)
3. [页面PID唯一性保障机制](#页面pid唯一性保障机制)
4. [跨表关联操作实现](#跨表关联操作实现)
5. [事务处理与数据一致性](#事务处理与数据一致性)
6. [索引设计与查询性能](#索引设计与查询性能)
7. [结论](#结论)

## 引言
本文档全面记录系统中的关联数据模型，重点分析 `user_page` 表如何实现用户与页面之间的多对多关系，以及 `unique_pid` 表如何确保页面PID的全局唯一性。结合SQL脚本与GORM Gen生成代码，展示跨表关联操作的实现方式，并讨论事务处理与索引设计对系统性能的影响。

## 用户-页面关联模型

`user_page` 表用于实现用户与页面之间的多对多映射关系，支持用户空间中页面的排序管理。该表通过联合唯一键约束确保每个用户对同一页面仅存在一条记录。

### 表结构设计
```sql
CREATE TABLE user_page (
    `id`            BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'auto increment ID',
    `uid`           BIGINT(20) DEFAULT 0 NOT NULL COMMENT 'user id',
    `pid`           VARCHAR(16) DEFAULT '' NOT NULL COMMENT 'origin page id，start with O',
    `sort`          INT(11) DEFAULT 0 NOT NULL COMMENT 'sort order of page',
    `deleted_at`    DATETIME                NULL,
    `created_at`    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'create time',
    `updated_at`    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'update time',
    PRIMARY KEY (`id`),
    UNIQUE KEY `uk_uid_pid` (`uid`, `pid`)
);
```

### GORM结构体映射
在 `user_page.gen.go` 中，`UserPage` 结构体通过GORM标签精确映射数据库字段，其中 `uid` 和 `pid` 联合构成唯一索引 `uk_uid_pid`，防止重复关联。

```go
type UserPage struct {
	ID        int64          `gorm:"column:id;type:bigint(20);primaryKey;autoIncrement:true;comment:auto increment ID" json:"id"`
	UID       int64          `gorm:"column:uid;type:bigint(20);not null;uniqueIndex:uk_uid_pid,priority:1;comment:user id" json:"uid"`
	Pid       string         `gorm:"column:pid;type:varchar(16);not null;uniqueIndex:uk_uid_pid,priority:2;comment:origin page id，start with O" json:"pid"`
	Sort      int64          `gorm:"column:sort;type:int(11);not null;comment:sort order of page" json:"sort"`
	DeletedAt gorm.DeletedAt `gorm:"column:deleted_at;type:datetime" json:"deleted_at"`
	CreatedAt *time.Time     `gorm:"column:created_at;type:datetime;not null;default:CURRENT_TIMESTAMP;comment:create time" json:"created_at"`
	UpdatedAt *time.Time     `gorm:"column:updated_at;type:datetime;not null;default:CURRENT_TIMESTAMP;comment:update time" json:"updated_at"`
}
```

### 查询接口能力
`user_page.gen.go` 提供了完整的CRUD操作接口，包括：
- `Create` / `CreateInBatches`：创建单条或多条用户-页面关联记录
- `Find` / `FindByPage`：根据条件查询用户拥有的页面列表
- `Delete`：软删除关联关系（通过 `deleted_at` 字段）
- `Where` / `Order` / `Limit`：支持链式查询构建

**Section sources**
- [user_page.sql](file://app/dal/gensql/user_page.sql#L1-L17)
- [user_page.gen.go](file://app/dal/model/user_page.gen.go#L1-L30)
- [user_page.gen.go](file://app/dal/query/user_page.gen.go#L1-L352)

## 页面PID唯一性保障机制

`unique_pid` 表负责确保系统中所有页面的PID全局唯一，避免命名冲突。

### 表结构设计
```sql
CREATE TABLE unique_pid (
    `id`            BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'auto increment ID',
    `pid`           VARCHAR(16) DEFAULT '' NOT NULL COMMENT 'unique page id',
    `uid`           BIGINT(20) DEFAULT 0 NOT NULL COMMENT 'user id',
    `created_at`    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'create time',
    `updated_at`    DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'update time',
    PRIMARY KEY (`id`),
    UNIQUE KEY `uk_pid` (`pid`)
);
```

### GORM结构体映射
`UniquePid` 结构体通过 `uniqueIndex:uk_pid` 确保 `pid` 字段的唯一性，防止重复插入。

```go
type UniquePid struct {
	ID        int64      `gorm:"column:id;type:bigint(20);primaryKey;autoIncrement:true;comment:auto increment ID" json:"id"`
	Pid       string     `gorm:"column:pid;type:varchar(16);not null;uniqueIndex:uk_pid,priority:1;comment:unique page id" json:"pid"`
	UID       int64      `gorm:"column:uid;type:bigint(20);not null;comment:user id" json:"uid"`
	CreatedAt *time.Time `gorm:"column:created_at;type:datetime;not null;default:CURRENT_TIMESTAMP;comment:create time" json:"created_at"`
	UpdatedAt *time.Time `gorm:"column:updated_at;type:datetime;not null;default:CURRENT_TIMESTAMP;comment:update time" json:"updated_at"`
}
```

### 创建页面时的校验流程
1. 调用 `UniquePid.Where(UniquePid.Pid.Eq(givenPid)).First()` 检查PID是否已存在
2. 若存在，返回冲突错误；若不存在，继续创建流程
3. 在事务中同时插入 `unique_pid` 和 `page` 表，保证原子性

**Section sources**
- [unique_pid.sql](file://app/dal/gensql/unique_pid.sql#L1-L11)
- [unique_pid.gen.go](file://app/dal/model/unique_pid.gen.go#L1-L25)
- [unique_pid.gen.go](file://app/dal/query/unique_pid.gen.go#L1-L345)

## 跨表关联操作实现

系统通过GORM Gen生成的查询接口实现高效的跨表关联操作。

### 查询某用户的所有页面
```go
// 使用 user_page 表查询用户关联的页面
pages, err := query.Q.UserPage.WithContext(ctx).
    Where(query.Q.UserPage.UID.Eq(userID)).
    Order(query.Q.UserPage.Sort).
    Find()
```

### 检查PID是否已被占用
```go
// 查询 unique_pid 表判断PID是否存在
exists, err := query.Q.UniquePid.WithContext(ctx).
    Where(query.Q.UniquePid.Pid.Eq(targetPID)).
    Exists()
```

### 多表协同创建页面
```go
err := query.Q.Transaction(func(tx *query.Query) error {
    // 1. 插入 unique_pid 表
    if err := tx.UniquePid.Create(&model.UniquePid{
        Pid: pid,
        UID: userID,
    }); err != nil {
        return err
    }

    // 2. 插入 page 表
    if err := tx.Page.Create(&model.Page{
        Pid: pid,
        UID: userID,
        // 其他字段...
    }); err != nil {
        return err
    }

    // 3. 建立用户-页面关联
    return tx.UserPage.Create(&model.UserPage{
        UID:  userID,
        Pid:  pid,
        Sort: 0,
    })
})
```

**Section sources**
- [user_page.gen.go](file://app/dal/query/user_page.gen.go#L202-L256)
- [unique_pid.gen.go](file://app/dal/query/unique_pid.gen.go#L202-L256)
- [gen.go](file://app/dal/query/gen.go#L68-L126)

## 事务处理与数据一致性

系统通过GORM的事务机制保证跨表操作的数据一致性。

### 事务接口设计
`gen.go` 提供了事务支持：
- `Transaction(fc func(tx *Query) error)`：执行事务函数
- `Begin()` / `Commit()` / `Rollback()`：手动事务控制

### 事务使用示例
```go
err := query.Q.Transaction(func(tx *query.Query) error {
    // 在同一事务中执行多个操作
    if err := tx.UniquePid.Create(uniquePidRecord); err != nil {
        return err
    }
    if err := tx.Page.Create(pageRecord); err != nil {
        return err
    }
    return tx.UserPage.Create(userPageRecord)
})
```
若任一操作失败，整个事务回滚，避免数据不一致。

**Section sources**
- [gen.go](file://app/dal/query/gen.go#L68-L126)

## 索引设计与查询性能

### 索引策略
- `user_page` 表：`uk_uid_pid` 联合唯一索引，优化按用户查询页面的性能
- `unique_pid` 表：`uk_pid` 唯一索引，加速PID存在性检查

### 查询效率影响
- 联合索引使 `WHERE uid = ? AND pid = ?` 查询达到O(log n)复杂度
- 唯一索引确保 `SELECT COUNT(*) FROM unique_pid WHERE pid = ?` 高效执行
- `sort` 字段未建索引，适用于小规模排序；若数据量大，可考虑添加索引

**Section sources**
- [user_page.sql](file://app/dal/gensql/user_page.sql#L1-L17)
- [unique_pid.sql](file://app/dal/gensql/unique_pid.sql#L1-L11)

## 结论
系统通过 `user_page` 表实现用户与页面的多对多关系，采用联合主键设计确保数据完整性。`unique_pid` 表通过唯一索引保障PID全局唯一性，结合事务机制实现安全的页面创建流程。GORM Gen生成的查询接口提供了类型安全、链式调用的数据库操作能力，配合合理的索引设计，确保了系统的高性能与数据一致性。